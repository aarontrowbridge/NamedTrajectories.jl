var documenterSearchIndex = {"docs":
[{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"EditURL = \"../../literate/man/plotting.jl\"","category":"page"},{"location":"man/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/tips/","page":"Tips and Tricks","title":"Tips and Tricks","text":"EditURL = \"../../literate/man/tips.jl\"","category":"page"},{"location":"man/tips/#Tips-and-Tricks","page":"Tips and Tricks","title":"Tips and Tricks","text":"","category":"section"},{"location":"man/tips/","page":"Tips and Tricks","title":"Tips and Tricks","text":"","category":"page"},{"location":"man/tips/","page":"Tips and Tricks","title":"Tips and Tricks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/#API","page":"Library","title":"API","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [\n    NamedTrajectories.MethodsNamedTrajectory,\n]","category":"page"},{"location":"lib/#Base.:==-Tuple{NamedTrajectory, NamedTrajectory}","page":"Library","title":"Base.:==","text":":(==)(traj1::NamedTrajectory, traj2::NamedTrajectory)\n\nCheck if trajectories are equal w.r.t. using Base.:(==)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.copy-Tuple{NamedTrajectory}","page":"Library","title":"Base.copy","text":"copy(::NamedTrajectory)\n\nReturns a copy of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.getindex-Tuple{NamedTrajectory, AbstractVector{Int64}}","page":"Library","title":"Base.getindex","text":"getindex(traj, ts::AbstractVector{Int})::Vector{KnotPoint}\n\nReturns the knot points at times ts.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.getindex-Tuple{NamedTrajectory, Int64}","page":"Library","title":"Base.getindex","text":"getindex(traj, t::Int)::KnotPoint\n\nReturns the knot point at time t.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.getindex-Tuple{NamedTrajectory, Symbol}","page":"Library","title":"Base.getindex","text":"getindex(traj, symb::Symbol)\n\nDispatches indexing of trajectories as either accessing a component or a property via getproperty.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.getproperty-Tuple{NamedTrajectory, Symbol}","page":"Library","title":"Base.getproperty","text":"getproperty(traj, symb::Symbol)\n\nReturns the component of the trajectory with name symb or the property of the trajectory with name symb.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.isequal-Tuple{NamedTrajectory, NamedTrajectory}","page":"Library","title":"Base.isequal","text":"isequal(traj1::NamedTrajectory, traj2::NamedTrajectory)\n\nCheck if trajectories are equal w.r.t. data using Base.isequal\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.lastindex-Tuple{NamedTrajectory}","page":"Library","title":"Base.lastindex","text":"lastindex(traj::NamedTrajectory)\n\nReturns the final time index of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.setproperty!-Tuple{NamedTrajectory, Symbol, Any}","page":"Library","title":"Base.setproperty!","text":"setproperty!(traj, name::Symbol, val::Any)\n\nDispatches setting properties of trajectories as either setting a component or a property via setfield! or update!.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.size-Tuple{NamedTrajectory}","page":"Library","title":"Base.size","text":"size(traj::NamedTrajectory) = (dim = traj.dim, T = traj.T)\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.add_component!-Tuple{NamedTrajectory, Symbol, AbstractVecOrMat{Float64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_component!","text":"add_component!(traj, name::Symbol, data::AbstractVecOrMat; type={:state, :control})\n\nAdd a component to the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.components-Tuple{NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.components","text":"components(::NamedTrajectory)\n\nReturns a NamedTuple containing the names and corresponding data matrices of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.remove_component-Tuple{NamedTrajectory, Symbol}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_component","text":"remove_component(traj, name::Symbol)\n\nRemove a component from the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.remove_components-Tuple{NamedTrajectory, Vector{Symbol}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_components","text":"remove_components(traj, names::Vector{Symbol})\n\nRemove a set of components from the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.times-Tuple{NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.times","text":"times(traj)::Vector{Float64}\n\nReturns the times of a trajectory as a vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.timesteps-Tuple{NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.timesteps","text":"timesteps(::NamedTrajectory)\n\nReturns the timesteps of a trajectory as a vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, Symbol, AbstractMatrix{Float64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","text":"update!(traj, name::Symbol, data::AbstractMatrix{Float64})\n\nUpdate a component of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.update_bound!","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update_bound!","text":"update_bound!(traj, name::Symbol, data::Real)\nupdate_bound!(traj, name::Symbol, data::AbstractVector{<:Real})\nupdate_bound!(traj, name::Symbol, data::Tuple{R, R} where R <: Real)\n\nUpdate the bound of a component of the trajectory.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To begin with install the package using the package manager","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"] add NamedTrajectories","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Then load the package","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using NamedTrajectories","category":"page"},{"location":"manual/#Creating-a-trajectory","page":"Manual","title":"Creating a trajectory","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"A trajectory is a collection of named vectors, each of which has the same length. Mathematically we have a collection of vectors","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"qtyz_t = qty(x_t  u_t)_t=1T","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The vectors can be of any type, but must be named. The names are used to identify the vectors, and must be unique.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"data = (\n\n) ","category":"page"},{"location":"manual/#Retrieving-values","page":"Manual","title":"Retrieving values","text":"","category":"section"},{"location":"manual/#Plotting","page":"Manual","title":"Plotting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = NamedTrajectories","category":"page"},{"location":"#NamedTrajectories.jl","page":"Home","title":"NamedTrajectories.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NamedTrajectories.jl is designed to solve several problems encountered when solving trajectory optimization problems. Specifically, it aims to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Abstract away messy indexing and vectorization details required for interfacing with numerical solvers.\nEasily handle multiple trajectories with different names, e.g. various states and controls.\nSimple plotting of trajectories.\nProvide a variety of helpful methods for common tasks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NamedTrajectories]","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"EditURL = \"../../literate/man/quickstart.jl\"","category":"page"},{"location":"man/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"To begin let's load the package","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using NamedTrajectories","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"A trajectory is a collection of named vectors, each of which has the same length. Mathematically we have a collection of vectors","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"qtyz_t = mqty(x_t  u_t)_t=1T","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"where x_t is the state and u_t is the control at a time indexed by t. Together z_t is referred to as a knot point and a NamedTrajectory essentially just stores a collection of knot points and makes it easy to access the state and control variables.","category":"page"},{"location":"man/quickstart/#Creating-a-fixed-timestep-NamedTrajectory","page":"Quickstart Guide","title":"Creating a fixed-timestep NamedTrajectory","text":"","category":"section"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Here we will createa a NamedTrajectory with a fixed timestep. This is done by passing a scalar as the timestep kwarg.","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n)\n\n# we must specify a timestep and control variable for the trajectory\ntimestep = 0.1\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Let's plot this trajectory","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(traj)","category":"page"},{"location":"man/quickstart/#Creating-a-variable-timestep-NamedTrajectory","page":"Quickstart Guide","title":"Creating a variable-timestep NamedTrajectory","text":"","category":"section"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Here we will create a NamedTrajectory with a variable timestep. This is done by passing a Symbol, corresponding to component of the data, as the timestep kwarg.","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names","category":"page"},{"location":"man/quickstart/#Adding-more-problem-data","page":"Quickstart Guide","title":"Adding more problem data","text":"","category":"section"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"In many settings we will want to add problem data to our NamedTrajectory – e.g. bounds, initial values, final values, and goal values. This is realized by passing NamedTuples containing this data.","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# define initial values\ninitial = (\n    x = [1.0, 0.0, 0.0],\n    u = [0.0, 0.0],\n)\n\n# define final value, here just on the control\nfinal = (\n    u = [0.0, 0.0],\n)\n\n# define bounds\nbounds = (\n    x = 1.0,\n    u = 1.0\n)\n\n# set a goal for the state\ngoal = (\n    x = [0.0, 0.0, 1.0],\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(\n    data;\n    timestep=timestep,\n    controls=control,\n    initial=initial,\n    final=final,\n    bounds=bounds,\n    goal=goal\n)\n\n# we can then show the bounds\ntraj.goal","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"page"},{"location":"man/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This page was generated using Literate.jl.","category":"page"}]
}
